<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <script>
/*! secrets.js-grempe 2019-09-07 */

// prettier-ignore
!function(t,e){"use strict";"function"==typeof define&&define.amd?define([],function(){return t.secrets=e()}):"object"==typeof exports?module.exports=e(require("crypto")):t.secrets=e(t.crypto)}(this,function(n){"use strict";var u,b,i,a,s;function h(){u={bits:8,radix:16,minBits:3,maxBits:20,bytesPerChar:2,maxBytesPerChar:6,primitivePolynomials:[null,null,1,3,3,5,3,3,29,17,9,5,83,27,43,3,45,9,39,39,9,5,3,33,27,9,71,39,9,5,83]},b={},i=new Array(1024).join("0"),a=!0,s=["nodeCryptoRandomBytes","browserCryptoGetRandomValues","testRandom"]}function f(){return!(!b||!b.rng||"function"!=typeof b.rng)}function g(t,e){var r;if(0===e||1===e)return t;if(e&&1024<e)throw new Error("Padding must be multiples of no larger than 1024 bits.");return e=e||b.bits,t&&(r=t.length%e),r?(i+t).slice(-(e-r+t.length)):t}function c(t){var e,r,n="";for(r=t.length-1;0<=r;r--){if(e=parseInt(t[r],16),isNaN(e))throw new Error("Invalid hex character.");n=g(e.toString(2),4)+n}return n}function m(t){var e,r,n="";for(r=(t=g(t,4)).length;4<=r;r-=4){if(e=parseInt(t.slice(r-4,r),2),isNaN(e))throw new Error("Invalid binary character.");n=e.toString(16)+n}return n}function o(){return!(!n||"object"!=typeof n||"function"!=typeof n.getRandomValues&&"object"!=typeof n.getRandomValues||"function"!=typeof Uint32Array&&"object"!=typeof Uint32Array)}function l(){return"object"==typeof n&&"function"==typeof n.randomBytes}function p(t){function a(t,e,r,n){var i,a=0,o="";for(e&&(i=e.length-1);a<i||o.length<t;)o+=g(Math.abs(parseInt(e[a],r)).toString(2),n),a++;return((o=o.substr(-t)).match(/0/g)||[]).length===o.length?null:o}function e(t){var e,r=null;for(16,4,e=Math.ceil(t/8);null===r;)r=a(t,n.randomBytes(e).toString("hex"),16,4);return r}function r(t){var e,r=null;for(10,32,e=Math.ceil(t/32);null===r;)r=a(t,n.getRandomValues(new Uint32Array(e)),10,32);return r}return t&&"testRandom"===t?(b.typeCSPRNG=t,function(t){var e,r,n=null;r=Math.ceil(t/32),e=new Uint32Array(r);for(var i=0;i<e.length;i++)e[i]=123456789;for(;null===n;)n=a(t,e,10,32);return n}):t&&"nodeCryptoRandomBytes"===t?(b.typeCSPRNG=t,e):t&&"browserCryptoGetRandomValues"===t?(b.typeCSPRNG=t,r):l()?(b.typeCSPRNG="nodeCryptoRandomBytes",e):o()?(b.typeCSPRNG="browserCryptoGetRandomValues",r):void 0}function d(t,e){var r,n=[];for(e&&(t=g(t,e)),r=t.length;r>b.bits;r-=b.bits)n.push(parseInt(t.slice(r-b.bits,r),2));return n.push(parseInt(t.slice(0,r),2)),n}function w(t,e){var r,n=b.logs[t],i=0;for(r=e.length-1;0<=r;r--)i=0!==i?b.exps[(n+b.logs[i])%b.maxShares]^e[r]:e[r];return i}function y(t,e,r){var n,i,a,o,s=0;for(a=0,n=e.length;a<n;a++)if(r[a]){for(i=b.logs[r[a]],o=0;o<n;o++)if(a!==o){if(t===e[o]){i=-1;break}i=(i+b.logs[t^e[o]]-b.logs[e[a]^e[o]]+b.maxShares)%b.maxShares}s=-1===i?s:s^b.exps[i]}return s}function x(t,e,r){var n,i,a=[],o=[t];for(n=1;n<r;n++)o[n]=parseInt(b.rng(b.bits),2);for(i=e+(n=1);n<i;n++)a[n-1]={x:n,y:w(n,o)};return a}function v(t,e,r){var n,i,a,o;if(e=parseInt(e,b.radix),n=(t=parseInt(t,10)||b.bits).toString(36).toUpperCase(),o=(a=Math.pow(2,t)-1).toString(b.radix).length,i=g(e.toString(b.radix),o),"number"!=typeof e||e%1!=0||e<1||a<e)throw new Error("Share id must be an integer between 1 and "+a+", inclusive.");return n+i+r}var t={init:function(t,e){var r,n,i=[],a=[],o=1;if(h(),t&&("number"!=typeof t||t%1!=0||t<u.minBits||t>u.maxBits))throw new Error("Number of bits must be an integer between "+u.minBits+" and "+u.maxBits+", inclusive.");if(e&&-1===s.indexOf(e))throw new Error("Invalid RNG type argument : '"+e+"'");for(b.radix=u.radix,b.bits=t||u.bits,b.size=Math.pow(2,b.bits),b.maxShares=b.size-1,r=u.primitivePolynomials[b.bits],n=0;n<b.size;n++)i[a[n]=o]=n,(o<<=1)>=b.size&&(o^=r,o&=b.maxShares);if(b.logs=i,b.exps=a,e&&this.setRNG(e),f()||this.setRNG(),!(f()&&b.bits&&b.size&&b.maxShares&&b.logs&&b.exps&&b.logs.length===b.size&&b.exps.length===b.size))throw new Error("Initialization failed.")},combine:function(t,e){var r,n,i,a,o,s,h,u="",f=[],l=[];for(e=e||0,r=0,i=t.length;r<i;r++){if(s=this.extractShareComponents(t[r]),void 0===o)o=s.bits;else if(s.bits!==o)throw new Error("Mismatched shares: Different bit settings.");if(b.bits!==o&&this.init(o),-1===f.indexOf(s.id))for(f.push(s.id),n=0,a=(h=d(c(s.data))).length;n<a;n++)l[n]=l[n]||[],l[n][f.length-1]=h[n]}for(r=0,i=l.length;r<i;r++)u=g(y(e,f,l[r]).toString(2))+u;return m(1<=e?u:u.slice(u.indexOf("1")+1))},getConfig:function(){var t={};return t.radix=b.radix,t.bits=b.bits,t.maxShares=b.maxShares,t.hasCSPRNG=f(),t.typeCSPRNG=b.typeCSPRNG,t},extractShareComponents:function(t){var e,r,n,i,a,o={};if((e=parseInt(t.substr(0,1),36))&&("number"!=typeof e||e%1!=0||e<u.minBits||e>u.maxBits))throw new Error("Invalid share : Number of bits must be an integer between "+u.minBits+" and "+u.maxBits+", inclusive.");if(i=Math.pow(2,e)-1,n=(Math.pow(2,e)-1).toString(b.radix).length,(a=new RegExp("^([a-kA-K3-9]{1})([a-fA-F0-9]{"+n+"})([a-fA-F0-9]+)$").exec(t))&&(r=parseInt(a[2],b.radix)),"number"!=typeof r||r%1!=0||r<1||i<r)throw new Error("Invalid share : Share id must be an integer between 1 and "+b.maxShares+", inclusive.");if(a&&a[3])return o.bits=e,o.id=r,o.data=a[3],o;throw new Error("The share data provided is invalid : "+t)},setRNG:function(t){var e="Random number generator is invalid ",r=" Supply an CSPRNG of the form function(bits){} that returns a string containing 'bits' number of random 1's and 0's.";if(t&&"string"==typeof t&&-1===s.indexOf(t))throw new Error("Invalid RNG type argument : '"+t+"'");if((t=t||p())&&"string"==typeof t&&(t=p(t)),a){if(t&&"function"!=typeof t)throw new Error(e+"(Not a function)."+r);if(t&&"string"!=typeof t(b.bits))throw new Error(e+"(Output is not a string)."+r);if(t&&!parseInt(t(b.bits),2))throw new Error(e+"(Binary string output not parseable to an Integer)."+r);if(t&&t(b.bits).length>b.bits)throw new Error(e+"(Output length is greater than config.bits)."+r);if(t&&t(b.bits).length<b.bits)throw new Error(e+"(Output length is less than config.bits)."+r)}return b.rng=t,!0},str2hex:function(t,e){var r,n,i,a,o,s,h="";if("string"!=typeof t)throw new Error("Input must be a character string.");if("number"!=typeof(e=e||u.bytesPerChar)||e<1||e>u.maxBytesPerChar||e%1!=0)throw new Error("Bytes per character must be an integer between 1 and "+u.maxBytesPerChar+", inclusive.");for(r=2*e,n=Math.pow(16,r)-1,o=0,s=t.length;o<s;o++){if(a=t[o].charCodeAt(),isNaN(a))throw new Error("Invalid character: "+t[o]);if(n<a)throw i=Math.ceil(Math.log(a+1)/Math.log(256)),new Error("Invalid character code ("+a+"). Maximum allowable is 256^bytes-1 ("+n+"). To convert this character, use at least "+i+" bytes.");h=g(a.toString(16),r)+h}return h},hex2str:function(t,e){var r,n,i,a="";if("string"!=typeof t)throw new Error("Input must be a hexadecimal string.");if("number"!=typeof(e=e||u.bytesPerChar)||e%1!=0||e<1||e>u.maxBytesPerChar)throw new Error("Bytes per character must be an integer between 1 and "+u.maxBytesPerChar+", inclusive.");for(n=0,i=(t=g(t,r=2*e)).length;n<i;n+=r)a=String.fromCharCode(parseInt(t.slice(n,n+r),16))+a;return a},random:function(t){if("number"!=typeof t||t%1!=0||t<2||65536<t)throw new Error("Number of bits must be an Integer between 1 and 65536.");return m(b.rng(t))},share:function(t,e,r,n){var i,a,o,s,h,u=new Array(e),f=new Array(e);if(n=n||128,"string"!=typeof t)throw new Error("Secret must be a string.");if("number"!=typeof e||e%1!=0||e<2)throw new Error("Number of shares must be an integer between 2 and 2^bits-1 ("+b.maxShares+"), inclusive.");if(e>b.maxShares)throw i=Math.ceil(Math.log(e+1)/Math.LN2),new Error("Number of shares must be an integer between 2 and 2^bits-1 ("+b.maxShares+"), inclusive. To create "+e+" shares, use at least "+i+" bits.");if("number"!=typeof r||r%1!=0||r<2)throw new Error("Threshold number of shares must be an integer between 2 and 2^bits-1 ("+b.maxShares+"), inclusive.");if(r>b.maxShares)throw i=Math.ceil(Math.log(r+1)/Math.LN2),new Error("Threshold number of shares must be an integer between 2 and 2^bits-1 ("+b.maxShares+"), inclusive.  To use a threshold of "+r+", use at least "+i+" bits.");if(e<r)throw new Error("Threshold number of shares was "+r+" but must be less than or equal to the "+e+" shares specified as the total to generate.");if("number"!=typeof n||n%1!=0||n<0||1024<n)throw new Error("Zero-pad length must be an integer between 0 and 1024 inclusive.");for(o=0,h=(t=d(t="1"+c(t),n)).length;o<h;o++)for(a=x(t[o],e,r),s=0;s<e;s++)u[s]=u[s]||a[s].x.toString(b.radix),f[s]=g(a[s].y.toString(2))+(f[s]||"");for(o=0;o<e;o++)u[o]=v(b.bits,u[o],m(f[o]));return u},newShare:function(t,e){var r;if(t&&"string"==typeof t&&(t=parseInt(t,b.radix)),r=t.toString(b.radix),t&&r&&e&&e[0])return v(this.extractShareComponents(e[0]).bits,r,this.combine(e,t));throw new Error("Invalid 'id' or 'shares' Array argument to newShare().")},_reset:h,_padLeft:g,_hex2bin:c,_bin2hex:m,_hasCryptoGetRandomValues:o,_hasCryptoRandomBytes:l,_getRNG:p,_isSetRNG:f,_splitNumStringToIntArray:d,_horner:w,_lagrange:y,_getShares:x,_constructPublicShareString:v};return t.init(),t});

</script>
        <script>
// prettier-ignore
const ccIcon = '<svg height="1rem" width="1rem" clip-rule="evenodd" fill-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="2" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m6 19v2c0 .621.52 1 1 1h2v-1.5h-1.5v-1.5zm7.5 3h-3.5v-1.5h3.5zm4.5 0h-3.5v-1.5h3.5zm4-3h-1.5v1.5h-1.5v1.5h2c.478 0 1-.379 1-1zm-1.5-1v-3.363h1.5v3.363zm0-4.363v-3.637h1.5v3.637zm-13-3.637v3.637h-1.5v-3.637zm11.5-4v1.5h1.5v1.5h1.5v-2c0-.478-.379-1-1-1zm-10 0h-2c-.62 0-1 .519-1 1v2h1.5v-1.5h1.5zm4.5 1.5h-3.5v-1.5h3.5zm3-1.5v-2.5h-13v13h2.5v-1.863h1.5v3.363h-4.5c-.48 0-1-.379-1-1v-14c0-.481.38-1 1-1h14c.621 0 1 .522 1 1v4.5h-3.5v-1.5z" fill-rule="nonzero"/></svg>';

</script>
        <script>
function copyToClipboard(elementId) {
    const element = document.getElementById(elementId);
    navigator.clipboard.writeText(element.innerText);

    element.style.backgroundColor = "#d4edda";
    setTimeout(() => {
        element.style.backgroundColor = "#f4f4f4";
    }, 300);
}

</script>
        <script>
// prettier-ignore
const template64 = "PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KICAgIDxoZWFkPgogICAgICAgIDxtZXRhIGNoYXJzZXQ9IlVURi04IiAvPgogICAgICAgIDxtZXRhIG5hbWU9InZpZXdwb3J0IiBjb250ZW50PSJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wIiAvPgogICAgICAgIDxtZXRhIGh0dHAtZXF1aXY9IlgtVUEtQ29tcGF0aWJsZSIgY29udGVudD0iaWU9ZWRnZSIgLz4KICAgICAgICA8dGl0bGU+UGFydCBfX1NFTEZfUEFSVF9OVU1CRVJfXyAoX19HUk9VUF9JRF9fKTwvdGl0bGU+CiAgICAgICAgPHN0eWxlPgptYWluIHsKICAgIG1heC13aWR0aDogODAwcHg7CiAgICBtYXJnaW46IGF1dG87CiAgICBmb250LWZhbWlseTogQXJpYWwsIHNhbnMtc2VyaWY7Cn0KCjpmb2N1cyB7CiAgICBvdXRsaW5lLWNvbG9yOiAjNGE5MGUyOwogICAgb3V0bGluZS13aWR0aDogMnB4OwogICAgb3V0bGluZS1zdHlsZTogc29saWQ7Cn0KCmlucHV0LAp0ZXh0YXJlYSB7CiAgICB3aWR0aDogMTAwJTsKICAgIHBhZGRpbmc6IDAuNXJlbTsKICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7CiAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjOwp9CgpidXR0b24gewogICAgcGFkZGluZzogMC41cmVtIDAuNXJlbTsKICAgIGJvcmRlci1yYWRpdXM6IDVweDsKICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7CiAgICBjdXJzb3I6IHBvaW50ZXI7Cn0KCm5hdiB7CiAgICBkaXNwbGF5OiBmbGV4OwogICAgcGFkZGluZzogMXJlbTsKICAgIG1hcmdpbi1ib3R0b206IDFyZW07CiAgICBnYXA6IDFyZW07CiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYzsKfQoKPC9zdHlsZT4KICAgICAgICA8c3R5bGU+Ci5zaGFyZS1jb250YWluZXIgewogICAgZGlzcGxheTogZmxleDsKICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICBnYXA6IDFyZW07CiAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07Cn0KCi5zaGFyZSB7CiAgICBmb250LWZhbWlseTogbW9ub3NwYWNlOwogICAgZm9udC1zaXplOiAwLjlyZW07CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0OwogICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjNzIGVhc2Utb3V0OwogICAgcGFkZGluZzogMXJlbSAwLjVyZW07CiAgICBib3JkZXItcmFkaXVzOiA1cHg7CiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7CiAgICBmbGV4LWdyb3c6IDE7CiAgICBvdmVyZmxvdy14OiBoaWRkZW47CiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpczsKfQoKZGV0YWlscy5jdGEgPiBzdW1tYXJ5IHN2ZyB7CiAgICAvKiBmaWxsOiBjdXJyZW50Q29sb3I7ICovCiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC41cyBlYXNlOwogICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpOwp9CgpkZXRhaWxzW29wZW5dLmN0YSA+IHN1bW1hcnkgc3ZnIHsKICAgIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7Cn0KCmRldGFpbHNbb3Blbl0uY3RhID4gc3VtbWFyeSB7CiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwOwogICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7Cn0KCi5jdGEgPiBzdW1tYXJ5IHsKICAgIG1hcmdpbi10b3A6IDUwcHg7CiAgICBwYWRkaW5nOiAxZW0gMWVtOwogICAgZm9udC1zaXplOiAxLjFyZW07CiAgICBjb2xvcjogIzMzMzsKICAgIGN1cnNvcjogcG9pbnRlcjsKICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7CiAgICB0cmFuc2l0aW9uOiBib3JkZXItcmFkaXVzIDAuM3MgZWFzZTsKCiAgICAvKiBSb2xsIG91ciBvd24gbWFya2VyICovCiAgICBkaXNwbGF5OiBmbGV4OwogICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7CiAgICBnYXA6IDAuNWVtOwoKICAgICY6Om1hcmtlciB7CiAgICAgICAgY29udGVudDogIiI7CiAgICAgICAganVzdGlmeS1zZWxmOiBlbmQ7CiAgICB9CiAgICAmOmhvdmVyIHsKICAgICAgICAvKiBjb2xvcjogIzY2NjsgKi8KICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjRmNGY0OwogICAgfQp9Cgo8L3N0eWxlPgogICAgICAgIDxzY3JpcHQ+CmZ1bmN0aW9uIGNvcHlUb0NsaXBib2FyZChlbGVtZW50SWQpIHsKICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpOwogICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoZWxlbWVudC5pbm5lclRleHQpOwoKICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gIiNkNGVkZGEiOwogICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAiI2Y0ZjRmNCI7CiAgICB9LCAzMDApOwp9Cgo8L3NjcmlwdD4KCiAgICAgICAgPCEtLSBDb21iaW5lIC0tPgogICAgICAgIDxzY3JpcHQ+CmNvbnN0IGNoZWNrSWNvbiA9CiAgICAnPHN2ZyBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiIGZpbGw9IiMyMmJiMzMiIGZvY3VzYWJsZT0iZmFsc2UiIGFyaWEtaGlkZGVuPSJ0cnVlIiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAybS0yIDE1LTUtNSAxLjQxLTEuNDFMMTAgMTQuMTdsNy41OS03LjU5TDE5IDh6Ij48L3BhdGg+PC9zdmc+JzsKCmNvbnN0IGNyb3NzSWNvbiA9CiAgICAnPHN2ZyBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiIGZpbGw9IiNiYjIyMzMiIGZvY3VzYWJsZT0iZmFsc2UiIGFyaWEtaGlkZGVuPSJ0cnVlIiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0xMiAyQzYuNDcgMiAyIDYuNDcgMiAxMnM0LjQ3IDEwIDEwIDEwIDEwLTQuNDcgMTAtMTBTMTcuNTMgMiAxMiAybTUgMTMuNTlMMTUuNTkgMTcgMTIgMTMuNDEgOC40MSAxNyA3IDE1LjU5IDEwLjU5IDEyIDcgOC40MSA4LjQxIDcgMTIgMTAuNTkgMTUuNTkgNyAxNyA4LjQxIDEzLjQxIDEyeiI+PC9wYXRoPjwvc3ZnPic7Cgpjb25zdCBhcnJvd1JpZ2h0SWNvbiA9CiAgICAnPHN2ZyBoZWlnaHQ9IjI0IiB3aWR0aD0iMjQiIGZpbGw9IiMzMzMzYmIiIGZvY3VzYWJsZT0iZmFsc2UiIGFyaWEtaGlkZGVuPSJ0cnVlIiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0yMiAxMmMwLTUuNTItNC40OC0xMC0xMC0xMFMyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBtLTEwIDFIOHYtMmg0VjhsNCA0LTQgNHoiPjwvcGF0aD48L3N2Zz4nOwoKPC9zY3JpcHQ+CiAgICAgICAgPHNjcmlwdD4KLyohIHNlY3JldHMuanMtZ3JlbXBlIDIwMTktMDktMDcgKi8KCi8vIHByZXR0aWVyLWlnbm9yZQohZnVuY3Rpb24odCxlKXsidXNlIHN0cmljdCI7ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sZnVuY3Rpb24oKXtyZXR1cm4gdC5zZWNyZXRzPWUoKX0pOiJvYmplY3QiPT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1lKHJlcXVpcmUoImNyeXB0byIpKTp0LnNlY3JldHM9ZSh0LmNyeXB0byl9KHRoaXMsZnVuY3Rpb24obil7InVzZSBzdHJpY3QiO3ZhciB1LGIsaSxhLHM7ZnVuY3Rpb24gaCgpe3U9e2JpdHM6OCxyYWRpeDoxNixtaW5CaXRzOjMsbWF4Qml0czoyMCxieXRlc1BlckNoYXI6MixtYXhCeXRlc1BlckNoYXI6NixwcmltaXRpdmVQb2x5bm9taWFsczpbbnVsbCxudWxsLDEsMywzLDUsMywzLDI5LDE3LDksNSw4MywyNyw0MywzLDQ1LDksMzksMzksOSw1LDMsMzMsMjcsOSw3MSwzOSw5LDUsODNdfSxiPXt9LGk9bmV3IEFycmF5KDEwMjQpLmpvaW4oIjAiKSxhPSEwLHM9WyJub2RlQ3J5cHRvUmFuZG9tQnl0ZXMiLCJicm93c2VyQ3J5cHRvR2V0UmFuZG9tVmFsdWVzIiwidGVzdFJhbmRvbSJdfWZ1bmN0aW9uIGYoKXtyZXR1cm4hKCFifHwhYi5ybmd8fCJmdW5jdGlvbiIhPXR5cGVvZiBiLnJuZyl9ZnVuY3Rpb24gZyh0LGUpe3ZhciByO2lmKDA9PT1lfHwxPT09ZSlyZXR1cm4gdDtpZihlJiYxMDI0PGUpdGhyb3cgbmV3IEVycm9yKCJQYWRkaW5nIG11c3QgYmUgbXVsdGlwbGVzIG9mIG5vIGxhcmdlciB0aGFuIDEwMjQgYml0cy4iKTtyZXR1cm4gZT1lfHxiLmJpdHMsdCYmKHI9dC5sZW5ndGglZSkscj8oaSt0KS5zbGljZSgtKGUtcit0Lmxlbmd0aCkpOnR9ZnVuY3Rpb24gYyh0KXt2YXIgZSxyLG49IiI7Zm9yKHI9dC5sZW5ndGgtMTswPD1yO3ItLSl7aWYoZT1wYXJzZUludCh0W3JdLDE2KSxpc05hTihlKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgaGV4IGNoYXJhY3Rlci4iKTtuPWcoZS50b1N0cmluZygyKSw0KStufXJldHVybiBufWZ1bmN0aW9uIG0odCl7dmFyIGUscixuPSIiO2ZvcihyPSh0PWcodCw0KSkubGVuZ3RoOzQ8PXI7ci09NCl7aWYoZT1wYXJzZUludCh0LnNsaWNlKHItNCxyKSwyKSxpc05hTihlKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYmluYXJ5IGNoYXJhY3Rlci4iKTtuPWUudG9TdHJpbmcoMTYpK259cmV0dXJuIG59ZnVuY3Rpb24gbygpe3JldHVybiEoIW58fCJvYmplY3QiIT10eXBlb2Ygbnx8ImZ1bmN0aW9uIiE9dHlwZW9mIG4uZ2V0UmFuZG9tVmFsdWVzJiYib2JqZWN0IiE9dHlwZW9mIG4uZ2V0UmFuZG9tVmFsdWVzfHwiZnVuY3Rpb24iIT10eXBlb2YgVWludDMyQXJyYXkmJiJvYmplY3QiIT10eXBlb2YgVWludDMyQXJyYXkpfWZ1bmN0aW9uIGwoKXtyZXR1cm4ib2JqZWN0Ij09dHlwZW9mIG4mJiJmdW5jdGlvbiI9PXR5cGVvZiBuLnJhbmRvbUJ5dGVzfWZ1bmN0aW9uIHAodCl7ZnVuY3Rpb24gYSh0LGUscixuKXt2YXIgaSxhPTAsbz0iIjtmb3IoZSYmKGk9ZS5sZW5ndGgtMSk7YTxpfHxvLmxlbmd0aDx0OylvKz1nKE1hdGguYWJzKHBhcnNlSW50KGVbYV0scikpLnRvU3RyaW5nKDIpLG4pLGErKztyZXR1cm4oKG89by5zdWJzdHIoLXQpKS5tYXRjaCgvMC9nKXx8W10pLmxlbmd0aD09PW8ubGVuZ3RoP251bGw6b31mdW5jdGlvbiBlKHQpe3ZhciBlLHI9bnVsbDtmb3IoMTYsNCxlPU1hdGguY2VpbCh0LzgpO251bGw9PT1yOylyPWEodCxuLnJhbmRvbUJ5dGVzKGUpLnRvU3RyaW5nKCJoZXgiKSwxNiw0KTtyZXR1cm4gcn1mdW5jdGlvbiByKHQpe3ZhciBlLHI9bnVsbDtmb3IoMTAsMzIsZT1NYXRoLmNlaWwodC8zMik7bnVsbD09PXI7KXI9YSh0LG4uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShlKSksMTAsMzIpO3JldHVybiByfXJldHVybiB0JiYidGVzdFJhbmRvbSI9PT10PyhiLnR5cGVDU1BSTkc9dCxmdW5jdGlvbih0KXt2YXIgZSxyLG49bnVsbDtyPU1hdGguY2VpbCh0LzMyKSxlPW5ldyBVaW50MzJBcnJheShyKTtmb3IodmFyIGk9MDtpPGUubGVuZ3RoO2krKyllW2ldPTEyMzQ1Njc4OTtmb3IoO251bGw9PT1uOyluPWEodCxlLDEwLDMyKTtyZXR1cm4gbn0pOnQmJiJub2RlQ3J5cHRvUmFuZG9tQnl0ZXMiPT09dD8oYi50eXBlQ1NQUk5HPXQsZSk6dCYmImJyb3dzZXJDcnlwdG9HZXRSYW5kb21WYWx1ZXMiPT09dD8oYi50eXBlQ1NQUk5HPXQscik6bCgpPyhiLnR5cGVDU1BSTkc9Im5vZGVDcnlwdG9SYW5kb21CeXRlcyIsZSk6bygpPyhiLnR5cGVDU1BSTkc9ImJyb3dzZXJDcnlwdG9HZXRSYW5kb21WYWx1ZXMiLHIpOnZvaWQgMH1mdW5jdGlvbiBkKHQsZSl7dmFyIHIsbj1bXTtmb3IoZSYmKHQ9Zyh0LGUpKSxyPXQubGVuZ3RoO3I+Yi5iaXRzO3ItPWIuYml0cyluLnB1c2gocGFyc2VJbnQodC5zbGljZShyLWIuYml0cyxyKSwyKSk7cmV0dXJuIG4ucHVzaChwYXJzZUludCh0LnNsaWNlKDAsciksMikpLG59ZnVuY3Rpb24gdyh0LGUpe3ZhciByLG49Yi5sb2dzW3RdLGk9MDtmb3Iocj1lLmxlbmd0aC0xOzA8PXI7ci0tKWk9MCE9PWk/Yi5leHBzWyhuK2IubG9nc1tpXSklYi5tYXhTaGFyZXNdXmVbcl06ZVtyXTtyZXR1cm4gaX1mdW5jdGlvbiB5KHQsZSxyKXt2YXIgbixpLGEsbyxzPTA7Zm9yKGE9MCxuPWUubGVuZ3RoO2E8bjthKyspaWYoclthXSl7Zm9yKGk9Yi5sb2dzW3JbYV1dLG89MDtvPG47bysrKWlmKGEhPT1vKXtpZih0PT09ZVtvXSl7aT0tMTticmVha31pPShpK2IubG9nc1t0XmVbb11dLWIubG9nc1tlW2FdXmVbb11dK2IubWF4U2hhcmVzKSViLm1heFNoYXJlc31zPS0xPT09aT9zOnNeYi5leHBzW2ldfXJldHVybiBzfWZ1bmN0aW9uIHgodCxlLHIpe3ZhciBuLGksYT1bXSxvPVt0XTtmb3Iobj0xO248cjtuKyspb1tuXT1wYXJzZUludChiLnJuZyhiLmJpdHMpLDIpO2ZvcihpPWUrKG49MSk7bjxpO24rKylhW24tMV09e3g6bix5OncobixvKX07cmV0dXJuIGF9ZnVuY3Rpb24gdih0LGUscil7dmFyIG4saSxhLG87aWYoZT1wYXJzZUludChlLGIucmFkaXgpLG49KHQ9cGFyc2VJbnQodCwxMCl8fGIuYml0cykudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKCksbz0oYT1NYXRoLnBvdygyLHQpLTEpLnRvU3RyaW5nKGIucmFkaXgpLmxlbmd0aCxpPWcoZS50b1N0cmluZyhiLnJhZGl4KSxvKSwibnVtYmVyIiE9dHlwZW9mIGV8fGUlMSE9MHx8ZTwxfHxhPGUpdGhyb3cgbmV3IEVycm9yKCJTaGFyZSBpZCBtdXN0IGJlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCAiK2ErIiwgaW5jbHVzaXZlLiIpO3JldHVybiBuK2krcn12YXIgdD17aW5pdDpmdW5jdGlvbih0LGUpe3ZhciByLG4saT1bXSxhPVtdLG89MTtpZihoKCksdCYmKCJudW1iZXIiIT10eXBlb2YgdHx8dCUxIT0wfHx0PHUubWluQml0c3x8dD51Lm1heEJpdHMpKXRocm93IG5ldyBFcnJvcigiTnVtYmVyIG9mIGJpdHMgbXVzdCBiZSBhbiBpbnRlZ2VyIGJldHdlZW4gIit1Lm1pbkJpdHMrIiBhbmQgIit1Lm1heEJpdHMrIiwgaW5jbHVzaXZlLiIpO2lmKGUmJi0xPT09cy5pbmRleE9mKGUpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBSTkcgdHlwZSBhcmd1bWVudCA6ICciK2UrIiciKTtmb3IoYi5yYWRpeD11LnJhZGl4LGIuYml0cz10fHx1LmJpdHMsYi5zaXplPU1hdGgucG93KDIsYi5iaXRzKSxiLm1heFNoYXJlcz1iLnNpemUtMSxyPXUucHJpbWl0aXZlUG9seW5vbWlhbHNbYi5iaXRzXSxuPTA7bjxiLnNpemU7bisrKWlbYVtuXT1vXT1uLChvPDw9MSk+PWIuc2l6ZSYmKG9ePXIsbyY9Yi5tYXhTaGFyZXMpO2lmKGIubG9ncz1pLGIuZXhwcz1hLGUmJnRoaXMuc2V0Uk5HKGUpLGYoKXx8dGhpcy5zZXRSTkcoKSwhKGYoKSYmYi5iaXRzJiZiLnNpemUmJmIubWF4U2hhcmVzJiZiLmxvZ3MmJmIuZXhwcyYmYi5sb2dzLmxlbmd0aD09PWIuc2l6ZSYmYi5leHBzLmxlbmd0aD09PWIuc2l6ZSkpdGhyb3cgbmV3IEVycm9yKCJJbml0aWFsaXphdGlvbiBmYWlsZWQuIil9LGNvbWJpbmU6ZnVuY3Rpb24odCxlKXt2YXIgcixuLGksYSxvLHMsaCx1PSIiLGY9W10sbD1bXTtmb3IoZT1lfHwwLHI9MCxpPXQubGVuZ3RoO3I8aTtyKyspe2lmKHM9dGhpcy5leHRyYWN0U2hhcmVDb21wb25lbnRzKHRbcl0pLHZvaWQgMD09PW8pbz1zLmJpdHM7ZWxzZSBpZihzLmJpdHMhPT1vKXRocm93IG5ldyBFcnJvcigiTWlzbWF0Y2hlZCBzaGFyZXM6IERpZmZlcmVudCBiaXQgc2V0dGluZ3MuIik7aWYoYi5iaXRzIT09byYmdGhpcy5pbml0KG8pLC0xPT09Zi5pbmRleE9mKHMuaWQpKWZvcihmLnB1c2gocy5pZCksbj0wLGE9KGg9ZChjKHMuZGF0YSkpKS5sZW5ndGg7bjxhO24rKylsW25dPWxbbl18fFtdLGxbbl1bZi5sZW5ndGgtMV09aFtuXX1mb3Iocj0wLGk9bC5sZW5ndGg7cjxpO3IrKyl1PWcoeShlLGYsbFtyXSkudG9TdHJpbmcoMikpK3U7cmV0dXJuIG0oMTw9ZT91OnUuc2xpY2UodS5pbmRleE9mKCIxIikrMSkpfSxnZXRDb25maWc6ZnVuY3Rpb24oKXt2YXIgdD17fTtyZXR1cm4gdC5yYWRpeD1iLnJhZGl4LHQuYml0cz1iLmJpdHMsdC5tYXhTaGFyZXM9Yi5tYXhTaGFyZXMsdC5oYXNDU1BSTkc9ZigpLHQudHlwZUNTUFJORz1iLnR5cGVDU1BSTkcsdH0sZXh0cmFjdFNoYXJlQ29tcG9uZW50czpmdW5jdGlvbih0KXt2YXIgZSxyLG4saSxhLG89e307aWYoKGU9cGFyc2VJbnQodC5zdWJzdHIoMCwxKSwzNikpJiYoIm51bWJlciIhPXR5cGVvZiBlfHxlJTEhPTB8fGU8dS5taW5CaXRzfHxlPnUubWF4Qml0cykpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIHNoYXJlIDogTnVtYmVyIG9mIGJpdHMgbXVzdCBiZSBhbiBpbnRlZ2VyIGJldHdlZW4gIit1Lm1pbkJpdHMrIiBhbmQgIit1Lm1heEJpdHMrIiwgaW5jbHVzaXZlLiIpO2lmKGk9TWF0aC5wb3coMixlKS0xLG49KE1hdGgucG93KDIsZSktMSkudG9TdHJpbmcoYi5yYWRpeCkubGVuZ3RoLChhPW5ldyBSZWdFeHAoIl4oW2Eta0EtSzMtOV17MX0pKFthLWZBLUYwLTldeyIrbisifSkoW2EtZkEtRjAtOV0rKSQiKS5leGVjKHQpKSYmKHI9cGFyc2VJbnQoYVsyXSxiLnJhZGl4KSksIm51bWJlciIhPXR5cGVvZiByfHxyJTEhPTB8fHI8MXx8aTxyKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBzaGFyZSA6IFNoYXJlIGlkIG11c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kICIrYi5tYXhTaGFyZXMrIiwgaW5jbHVzaXZlLiIpO2lmKGEmJmFbM10pcmV0dXJuIG8uYml0cz1lLG8uaWQ9cixvLmRhdGE9YVszXSxvO3Rocm93IG5ldyBFcnJvcigiVGhlIHNoYXJlIGRhdGEgcHJvdmlkZWQgaXMgaW52YWxpZCA6ICIrdCl9LHNldFJORzpmdW5jdGlvbih0KXt2YXIgZT0iUmFuZG9tIG51bWJlciBnZW5lcmF0b3IgaXMgaW52YWxpZCAiLHI9IiBTdXBwbHkgYW4gQ1NQUk5HIG9mIHRoZSBmb3JtIGZ1bmN0aW9uKGJpdHMpe30gdGhhdCByZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgJ2JpdHMnIG51bWJlciBvZiByYW5kb20gMSdzIGFuZCAwJ3MuIjtpZih0JiYic3RyaW5nIj09dHlwZW9mIHQmJi0xPT09cy5pbmRleE9mKHQpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBSTkcgdHlwZSBhcmd1bWVudCA6ICciK3QrIiciKTtpZigodD10fHxwKCkpJiYic3RyaW5nIj09dHlwZW9mIHQmJih0PXAodCkpLGEpe2lmKHQmJiJmdW5jdGlvbiIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcihlKyIoTm90IGEgZnVuY3Rpb24pLiIrcik7aWYodCYmInN0cmluZyIhPXR5cGVvZiB0KGIuYml0cykpdGhyb3cgbmV3IEVycm9yKGUrIihPdXRwdXQgaXMgbm90IGEgc3RyaW5nKS4iK3IpO2lmKHQmJiFwYXJzZUludCh0KGIuYml0cyksMikpdGhyb3cgbmV3IEVycm9yKGUrIihCaW5hcnkgc3RyaW5nIG91dHB1dCBub3QgcGFyc2VhYmxlIHRvIGFuIEludGVnZXIpLiIrcik7aWYodCYmdChiLmJpdHMpLmxlbmd0aD5iLmJpdHMpdGhyb3cgbmV3IEVycm9yKGUrIihPdXRwdXQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiBjb25maWcuYml0cykuIityKTtpZih0JiZ0KGIuYml0cykubGVuZ3RoPGIuYml0cyl0aHJvdyBuZXcgRXJyb3IoZSsiKE91dHB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIGNvbmZpZy5iaXRzKS4iK3IpfXJldHVybiBiLnJuZz10LCEwfSxzdHIyaGV4OmZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpLGEsbyxzLGg9IiI7aWYoInN0cmluZyIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcigiSW5wdXQgbXVzdCBiZSBhIGNoYXJhY3RlciBzdHJpbmcuIik7aWYoIm51bWJlciIhPXR5cGVvZihlPWV8fHUuYnl0ZXNQZXJDaGFyKXx8ZTwxfHxlPnUubWF4Qnl0ZXNQZXJDaGFyfHxlJTEhPTApdGhyb3cgbmV3IEVycm9yKCJCeXRlcyBwZXIgY2hhcmFjdGVyIG11c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kICIrdS5tYXhCeXRlc1BlckNoYXIrIiwgaW5jbHVzaXZlLiIpO2ZvcihyPTIqZSxuPU1hdGgucG93KDE2LHIpLTEsbz0wLHM9dC5sZW5ndGg7bzxzO28rKyl7aWYoYT10W29dLmNoYXJDb2RlQXQoKSxpc05hTihhKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY2hhcmFjdGVyOiAiK3Rbb10pO2lmKG48YSl0aHJvdyBpPU1hdGguY2VpbChNYXRoLmxvZyhhKzEpL01hdGgubG9nKDI1NikpLG5ldyBFcnJvcigiSW52YWxpZCBjaGFyYWN0ZXIgY29kZSAoIithKyIpLiBNYXhpbXVtIGFsbG93YWJsZSBpcyAyNTZeYnl0ZXMtMSAoIituKyIpLiBUbyBjb252ZXJ0IHRoaXMgY2hhcmFjdGVyLCB1c2UgYXQgbGVhc3QgIitpKyIgYnl0ZXMuIik7aD1nKGEudG9TdHJpbmcoMTYpLHIpK2h9cmV0dXJuIGh9LGhleDJzdHI6ZnVuY3Rpb24odCxlKXt2YXIgcixuLGksYT0iIjtpZigic3RyaW5nIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKCJJbnB1dCBtdXN0IGJlIGEgaGV4YWRlY2ltYWwgc3RyaW5nLiIpO2lmKCJudW1iZXIiIT10eXBlb2YoZT1lfHx1LmJ5dGVzUGVyQ2hhcil8fGUlMSE9MHx8ZTwxfHxlPnUubWF4Qnl0ZXNQZXJDaGFyKXRocm93IG5ldyBFcnJvcigiQnl0ZXMgcGVyIGNoYXJhY3RlciBtdXN0IGJlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCAiK3UubWF4Qnl0ZXNQZXJDaGFyKyIsIGluY2x1c2l2ZS4iKTtmb3Iobj0wLGk9KHQ9Zyh0LHI9MiplKSkubGVuZ3RoO248aTtuKz1yKWE9U3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh0LnNsaWNlKG4sbityKSwxNikpK2E7cmV0dXJuIGF9LHJhbmRvbTpmdW5jdGlvbih0KXtpZigibnVtYmVyIiE9dHlwZW9mIHR8fHQlMSE9MHx8dDwyfHw2NTUzNjx0KXRocm93IG5ldyBFcnJvcigiTnVtYmVyIG9mIGJpdHMgbXVzdCBiZSBhbiBJbnRlZ2VyIGJldHdlZW4gMSBhbmQgNjU1MzYuIik7cmV0dXJuIG0oYi5ybmcodCkpfSxzaGFyZTpmdW5jdGlvbih0LGUscixuKXt2YXIgaSxhLG8scyxoLHU9bmV3IEFycmF5KGUpLGY9bmV3IEFycmF5KGUpO2lmKG49bnx8MTI4LCJzdHJpbmciIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoIlNlY3JldCBtdXN0IGJlIGEgc3RyaW5nLiIpO2lmKCJudW1iZXIiIT10eXBlb2YgZXx8ZSUxIT0wfHxlPDIpdGhyb3cgbmV3IEVycm9yKCJOdW1iZXIgb2Ygc2hhcmVzIG11c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDIgYW5kIDJeYml0cy0xICgiK2IubWF4U2hhcmVzKyIpLCBpbmNsdXNpdmUuIik7aWYoZT5iLm1heFNoYXJlcyl0aHJvdyBpPU1hdGguY2VpbChNYXRoLmxvZyhlKzEpL01hdGguTE4yKSxuZXcgRXJyb3IoIk51bWJlciBvZiBzaGFyZXMgbXVzdCBiZSBhbiBpbnRlZ2VyIGJldHdlZW4gMiBhbmQgMl5iaXRzLTEgKCIrYi5tYXhTaGFyZXMrIiksIGluY2x1c2l2ZS4gVG8gY3JlYXRlICIrZSsiIHNoYXJlcywgdXNlIGF0IGxlYXN0ICIraSsiIGJpdHMuIik7aWYoIm51bWJlciIhPXR5cGVvZiByfHxyJTEhPTB8fHI8Mil0aHJvdyBuZXcgRXJyb3IoIlRocmVzaG9sZCBudW1iZXIgb2Ygc2hhcmVzIG11c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDIgYW5kIDJeYml0cy0xICgiK2IubWF4U2hhcmVzKyIpLCBpbmNsdXNpdmUuIik7aWYocj5iLm1heFNoYXJlcyl0aHJvdyBpPU1hdGguY2VpbChNYXRoLmxvZyhyKzEpL01hdGguTE4yKSxuZXcgRXJyb3IoIlRocmVzaG9sZCBudW1iZXIgb2Ygc2hhcmVzIG11c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDIgYW5kIDJeYml0cy0xICgiK2IubWF4U2hhcmVzKyIpLCBpbmNsdXNpdmUuICBUbyB1c2UgYSB0aHJlc2hvbGQgb2YgIityKyIsIHVzZSBhdCBsZWFzdCAiK2krIiBiaXRzLiIpO2lmKGU8cil0aHJvdyBuZXcgRXJyb3IoIlRocmVzaG9sZCBudW1iZXIgb2Ygc2hhcmVzIHdhcyAiK3IrIiBidXQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlICIrZSsiIHNoYXJlcyBzcGVjaWZpZWQgYXMgdGhlIHRvdGFsIHRvIGdlbmVyYXRlLiIpO2lmKCJudW1iZXIiIT10eXBlb2Ygbnx8biUxIT0wfHxuPDB8fDEwMjQ8bil0aHJvdyBuZXcgRXJyb3IoIlplcm8tcGFkIGxlbmd0aCBtdXN0IGJlIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCAxMDI0IGluY2x1c2l2ZS4iKTtmb3Iobz0wLGg9KHQ9ZCh0PSIxIitjKHQpLG4pKS5sZW5ndGg7bzxoO28rKylmb3IoYT14KHRbb10sZSxyKSxzPTA7czxlO3MrKyl1W3NdPXVbc118fGFbc10ueC50b1N0cmluZyhiLnJhZGl4KSxmW3NdPWcoYVtzXS55LnRvU3RyaW5nKDIpKSsoZltzXXx8IiIpO2ZvcihvPTA7bzxlO28rKyl1W29dPXYoYi5iaXRzLHVbb10sbShmW29dKSk7cmV0dXJuIHV9LG5ld1NoYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIHI7aWYodCYmInN0cmluZyI9PXR5cGVvZiB0JiYodD1wYXJzZUludCh0LGIucmFkaXgpKSxyPXQudG9TdHJpbmcoYi5yYWRpeCksdCYmciYmZSYmZVswXSlyZXR1cm4gdih0aGlzLmV4dHJhY3RTaGFyZUNvbXBvbmVudHMoZVswXSkuYml0cyxyLHRoaXMuY29tYmluZShlLHQpKTt0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgJ2lkJyBvciAnc2hhcmVzJyBBcnJheSBhcmd1bWVudCB0byBuZXdTaGFyZSgpLiIpfSxfcmVzZXQ6aCxfcGFkTGVmdDpnLF9oZXgyYmluOmMsX2JpbjJoZXg6bSxfaGFzQ3J5cHRvR2V0UmFuZG9tVmFsdWVzOm8sX2hhc0NyeXB0b1JhbmRvbUJ5dGVzOmwsX2dldFJORzpwLF9pc1NldFJORzpmLF9zcGxpdE51bVN0cmluZ1RvSW50QXJyYXk6ZCxfaG9ybmVyOncsX2xhZ3JhbmdlOnksX2dldFNoYXJlczp4LF9jb25zdHJ1Y3RQdWJsaWNTaGFyZVN0cmluZzp2fTtyZXR1cm4gdC5pbml0KCksdH0pOwoKPC9zY3JpcHQ+CiAgICAgICAgPHNjcmlwdD4KY29uc3QgYmFzZTY0YWJjID0gWwogICAgIkEiLAogICAgIkIiLAogICAgIkMiLAogICAgIkQiLAogICAgIkUiLAogICAgIkYiLAogICAgIkciLAogICAgIkgiLAogICAgIkkiLAogICAgIkoiLAogICAgIksiLAogICAgIkwiLAogICAgIk0iLAogICAgIk4iLAogICAgIk8iLAogICAgIlAiLAogICAgIlEiLAogICAgIlIiLAogICAgIlMiLAogICAgIlQiLAogICAgIlUiLAogICAgIlYiLAogICAgIlciLAogICAgIlgiLAogICAgIlkiLAogICAgIloiLAogICAgImEiLAogICAgImIiLAogICAgImMiLAogICAgImQiLAogICAgImUiLAogICAgImYiLAogICAgImciLAogICAgImgiLAogICAgImkiLAogICAgImoiLAogICAgImsiLAogICAgImwiLAogICAgIm0iLAogICAgIm4iLAogICAgIm8iLAogICAgInAiLAogICAgInEiLAogICAgInIiLAogICAgInMiLAogICAgInQiLAogICAgInUiLAogICAgInYiLAogICAgInciLAogICAgIngiLAogICAgInkiLAogICAgInoiLAogICAgIjAiLAogICAgIjEiLAogICAgIjIiLAogICAgIjMiLAogICAgIjQiLAogICAgIjUiLAogICAgIjYiLAogICAgIjciLAogICAgIjgiLAogICAgIjkiLAogICAgIisiLAogICAgIi8iLApdOwoKY29uc3QgYmFzZTY0Y29kZXMgPSBbCiAgICAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LAogICAgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwKICAgIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgNjIsIDI1NSwKICAgIDI1NSwgMjU1LCA2MywgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNTgsIDU5LCA2MCwgNjEsIDI1NSwgMjU1LCAyNTUsIDAsIDI1NSwKICAgIDI1NSwgMjU1LCAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LAogICAgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI2LCAyNywgMjgsIDI5LAogICAgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCA0NCwgNDUsIDQ2LCA0NywgNDgsCiAgICA0OSwgNTAsIDUxLApdOwoKZnVuY3Rpb24gZ2V0QmFzZTY0Q29kZShjaGFyQ29kZSkgewogICAgaWYgKGNoYXJDb2RlID49IGJhc2U2NGNvZGVzLmxlbmd0aCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiVW5hYmxlIHRvIHBhcnNlIGJhc2U2NCBzdHJpbmcuIik7CiAgICB9CiAgICBjb25zdCBjb2RlID0gYmFzZTY0Y29kZXNbY2hhckNvZGVdOwogICAgaWYgKGNvZGUgPT09IDI1NSB8fCBjb2RlID09PSB1bmRlZmluZWQpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlVuYWJsZSB0byBwYXJzZSBiYXNlNjQgc3RyaW5nLiIpOwogICAgfQogICAgcmV0dXJuIGNvZGU7Cn0KCmZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjQoaW5wdXQpIHsKICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpOwoKICAgIGxldCByZXN1bHQgPSAiIjsKICAgIGxldCBpID0gMDsKICAgIGNvbnN0IGwgPSBieXRlcy5sZW5ndGg7CiAgICBmb3IgKGkgPSAyOyBpIDwgbDsgaSArPSAzKSB7CiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NGFiY1tieXRlc1tpIC0gMl0gPj4gMl07CiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NGFiY1soKGJ5dGVzW2kgLSAyXSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGVzW2kgLSAxXSA+PiA0KV07CiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NGFiY1soKGJ5dGVzW2kgLSAxXSAmIDB4MGYpIDw8IDIpIHwgKGJ5dGVzW2ldID4+IDYpXTsKICAgICAgICByZXN1bHQgKz0gYmFzZTY0YWJjW2J5dGVzW2ldICYgMHgzZl07CiAgICB9CiAgICBpZiAoaSA9PT0gbCArIDEpIHsKICAgICAgICAvLyAxIG9jdGV0IHlldCB0byB3cml0ZQogICAgICAgIHJlc3VsdCArPSBiYXNlNjRhYmNbYnl0ZXNbaSAtIDJdID4+IDJdOwogICAgICAgIHJlc3VsdCArPSBiYXNlNjRhYmNbKGJ5dGVzW2kgLSAyXSAmIDB4MDMpIDw8IDRdOwogICAgICAgIHJlc3VsdCArPSAiPT0iOwogICAgfQogICAgaWYgKGkgPT09IGwpIHsKICAgICAgICAvLyAyIG9jdGV0cyB5ZXQgdG8gd3JpdGUKICAgICAgICByZXN1bHQgKz0gYmFzZTY0YWJjW2J5dGVzW2kgLSAyXSA+PiAyXTsKICAgICAgICByZXN1bHQgKz0gYmFzZTY0YWJjWygoYnl0ZXNbaSAtIDJdICYgMHgwMykgPDwgNCkgfCAoYnl0ZXNbaSAtIDFdID4+IDQpXTsKICAgICAgICByZXN1bHQgKz0gYmFzZTY0YWJjWyhieXRlc1tpIC0gMV0gJiAweDBmKSA8PCAyXTsKICAgICAgICByZXN1bHQgKz0gIj0iOwogICAgfQogICAgcmV0dXJuIHJlc3VsdDsKfQoKZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhzdHIpIHsKICAgIGlmIChzdHIubGVuZ3RoICUgNCAhPT0gMCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiVW5hYmxlIHRvIHBhcnNlIGJhc2U2NCBzdHJpbmcuIik7CiAgICB9CiAgICBjb25zdCBpbmRleCA9IHN0ci5pbmRleE9mKCI9Iik7CiAgICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4IDwgc3RyLmxlbmd0aCAtIDIpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlVuYWJsZSB0byBwYXJzZSBiYXNlNjQgc3RyaW5nLiIpOwogICAgfQogICAgY29uc3QgbWlzc2luZ09jdGV0cyA9IHN0ci5lbmRzV2l0aCgiPT0iKSA/IDIgOiBzdHIuZW5kc1dpdGgoIj0iKSA/IDEgOiAwOwogICAgY29uc3QgbiA9IHN0ci5sZW5ndGg7CiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgzICogKG4gLyA0KSk7CiAgICBsZXQgYnVmZmVyOwogICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgbjsgaSArPSA0LCBqICs9IDMpIHsKICAgICAgICBidWZmZXIgPQogICAgICAgICAgICAoZ2V0QmFzZTY0Q29kZShzdHIuY2hhckNvZGVBdChpKSkgPDwgMTgpIHwKICAgICAgICAgICAgKGdldEJhc2U2NENvZGUoc3RyLmNoYXJDb2RlQXQoaSArIDEpKSA8PCAxMikgfAogICAgICAgICAgICAoZ2V0QmFzZTY0Q29kZShzdHIuY2hhckNvZGVBdChpICsgMikpIDw8IDYpIHwKICAgICAgICAgICAgZ2V0QmFzZTY0Q29kZShzdHIuY2hhckNvZGVBdChpICsgMykpOwogICAgICAgIHJlc3VsdFtqXSA9IGJ1ZmZlciA+PiAxNjsKICAgICAgICByZXN1bHRbaiArIDFdID0gKGJ1ZmZlciA+PiA4KSAmIDB4ZmY7CiAgICAgICAgcmVzdWx0W2ogKyAyXSA9IGJ1ZmZlciAmIDB4ZmY7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0LmJ1ZmZlci5zbGljZSgwLCByZXN1bHQubGVuZ3RoIC0gbWlzc2luZ09jdGV0cyk7Cn0KCjwvc2NyaXB0PgogICAgICAgIDxzY3JpcHQ+CmZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tQnl0ZXMobGVuZ3RoKSB7CiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7CiAgICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7CiAgICByZXR1cm4gYnl0ZXMuYnVmZmVyOwp9Cgphc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUtleUZyb21QYXNzd29yZChwYXNzd29yZCwgc2FsdCwgbW9kZSwgb3B0aW9ucykgewogICAgY29uc3QgcGFzc3dvcmRLZXkgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoCiAgICAgICAgInJhdyIsCiAgICAgICAgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHBhc3N3b3JkKSwKICAgICAgICB7IG5hbWU6ICJQQktERjIiIH0sCiAgICAgICAgZmFsc2UsCiAgICAgICAgWyJkZXJpdmVLZXkiXQogICAgKTsKCiAgICByZXR1cm4gd2luZG93LmNyeXB0by5zdWJ0bGUuZGVyaXZlS2V5KAogICAgICAgIHsKICAgICAgICAgICAgbmFtZTogIlBCS0RGMiIsCiAgICAgICAgICAgIHNhbHQsCiAgICAgICAgICAgIGl0ZXJhdGlvbnM6IG9wdGlvbnMuaXRlcmF0aW9ucywKICAgICAgICAgICAgaGFzaDogIlNIQS0xIiwKICAgICAgICB9LAogICAgICAgIHBhc3N3b3JkS2V5LAogICAgICAgIHsKICAgICAgICAgICAgbmFtZTogIkFFUy1HQ00iLAogICAgICAgICAgICBsZW5ndGg6IG9wdGlvbnMua2V5U2l6ZSAqIDgsCiAgICAgICAgfSwKICAgICAgICBmYWxzZSwKICAgICAgICBbbW9kZV0KICAgICk7Cn0KCmZ1bmN0aW9uIGdldERlZmF1bHRPcHRpb25zKCkgewogICAgcmV0dXJuIHsKICAgICAgICBibG9ja1NpemU6IDE2LAogICAgICAgIHNhbHRTaXplOiAxNiwKICAgICAgICBpdGVyYXRpb25zOiAxMDAwMDAwLAogICAgICAgIGtleVNpemU6IDMyLAogICAgfTsKfQoKYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChpbnB1dCwgcGFzc3dvcmRTdHIsIG9wdGlvbnMgPSBnZXREZWZhdWx0T3B0aW9ucygpKSB7CiAgICBjb25zdCBzYWx0ID0gZ2VuZXJhdGVSYW5kb21CeXRlcyhvcHRpb25zLnNhbHRTaXplKTsKICAgIGNvbnN0IGtleSA9IGF3YWl0IGdlbmVyYXRlS2V5RnJvbVBhc3N3b3JkKAogICAgICAgIHBhc3N3b3JkU3RyLAogICAgICAgIHNhbHQsCiAgICAgICAgImVuY3J5cHQiLAogICAgICAgIG9wdGlvbnMKICAgICk7CgogICAgY29uc3QgaXYgPSBnZW5lcmF0ZVJhbmRvbUJ5dGVzKG9wdGlvbnMuYmxvY2tTaXplKTsKCiAgICBjb25zdCBjaXBoZXJCdWZmZXIgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5lbmNyeXB0KAogICAgICAgIHsgbmFtZTogIkFFUy1HQ00iLCBpdiB9LAogICAgICAgIGtleSwKICAgICAgICBpbnB1dAogICAgKTsKCiAgICByZXR1cm4gewogICAgICAgIG9wdGlvbnMsCiAgICAgICAgc2FsdCwKICAgICAgICBpdiwKICAgICAgICBlbmNyeXB0ZWREYXRhOiBjaXBoZXJCdWZmZXIsCiAgICB9Owp9Cgphc3luYyBmdW5jdGlvbiBkZWNyeXB0KGRhdGEsIHBhc3N3b3JkU3RyKSB7CiAgICBjb25zdCBrZXkgPSBhd2FpdCBnZW5lcmF0ZUtleUZyb21QYXNzd29yZCgKICAgICAgICBwYXNzd29yZFN0ciwKICAgICAgICBkYXRhLnNhbHQsCiAgICAgICAgImRlY3J5cHQiLAogICAgICAgIGRhdGEub3B0aW9ucwogICAgKTsKCiAgICByZXR1cm4gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGVjcnlwdCgKICAgICAgICB7CiAgICAgICAgICAgIG5hbWU6ICJBRVMtR0NNIiwKICAgICAgICAgICAgaXY6IGRhdGEuaXYsCiAgICAgICAgfSwKICAgICAgICBrZXksCiAgICAgICAgZGF0YS5lbmNyeXB0ZWREYXRhCiAgICApOwp9Cgo8L3NjcmlwdD4KICAgICAgICA8c3R5bGU+CiNpbnB1dHMgewogICAgZGlzcGxheTogZ3JpZDsKICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogYXV0byAxZnI7CiAgICBnYXA6IDEwcHg7CiAgICBhbGlnbi1pdGVtczogY2VudGVyOwp9CgojaW5wdXRzIC5yb3cgewogICAganVzdGlmeS1zZWxmOiBlbmQ7Cn0KCi5yb3cgewogICAgZGlzcGxheTogZmxleDsKICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICBnYXA6IDEwcHg7Cn0KCiNvdXRwdXQgc3BhbiB7CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjlmOWY5OwogICAgcGFkZGluZzogMXJlbTsKICAgIGJvcmRlci1yYWRpdXM6IDVweDsKICAgIGJvcmRlcjogMXB4IGRhc2hlZCAjY2NjOwogICAgZm9udC1zaXplOiAwLjlyZW07CiAgICBmb250LXN0eWxlOiBpdGFsaWM7CiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7CiAgICB3aWR0aDogMTAwJTsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgIG92ZXJmbG93LXk6IGF1dG87Cn0KCiNvdXRwdXQgc3Bhbi5zZWNyZXQgewogICAgZm9udC1zdHlsZTogbm9ybWFsOwogICAgdGV4dC1hbGlnbjogaW5pdGlhbDsKICAgIHdoaXRlLXNwYWNlOiBwcmUtbGluZTsKfQoKPC9zdHlsZT4KICAgICAgICA8c2NyaXB0PgpmdW5jdGlvbiBjb21iaW5lKCkgewogICAgY29uc3QgcGFydHMgPSBnZXRQYXJ0cygpOwoKICAgIHVwZGF0ZVBhcnRzVWkocGFydHMpOwogICAgdXBkYXRlT3V0cHV0KHBhcnRzKTsKfQoKZnVuY3Rpb24gZ2V0UGFydHMoKSB7CiAgICBjb25zdCBwYXJ0cyA9IFtdOwoKICAgIGNvbnN0IGlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIiNpbnB1dHMgaW5wdXQiKTsKICAgIGZvciAoY29uc3QgaW5wdXQgb2YgaW5wdXRzKSB7CiAgICAgICAgY29uc3QgcGFydFZhbHVlID0gaW5wdXQudmFsdWUudHJpbSgpOwogICAgICAgIHBhcnRzLnB1c2gocGFydFZhbHVlKTsKICAgIH0KICAgIHJldHVybiBwYXJ0czsKfQoKYXN5bmMgZnVuY3Rpb24gdXBkYXRlT3V0cHV0KHBhcnRzKSB7CiAgICBjb25zdCBvdXRwdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgib3V0cHV0Iik7CiAgICB0cnkgewogICAgICAgIGNvbnN0IHNlY3JldCA9IGF3YWl0IGRlY29kZVBhcnRzKHBhcnRzKTsKCiAgICAgICAgb3V0cHV0LmlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz0ic2VjcmV0Ij4ke3NlY3JldH08L3NwYW4+YDsKICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICJPcGVyYXRpb25FcnJvciIpIHsKICAgICAgICAgICAgb3V0cHV0LmlubmVySFRNTCA9IGA8c3Bhbj5JbnZhbGlkIHBhc3N3b3JkPC9zcGFuPmA7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgb3V0cHV0LmlubmVySFRNTCA9IGA8c3Bhbj4ke2Vycm9yLm1lc3NhZ2V9PC9zcGFuPmA7CiAgICB9Cn0KCmFzeW5jIGZ1bmN0aW9uIGRlY29kZVBhcnRzKHBhcnRzKSB7CiAgICBjb25zdCBwYXNzd29yZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCJwYXNzd29yZCIpLnZhbHVlOwoKICAgIGNvbnN0IG5vbkVtcHR5UGFydHMgPSBwYXJ0cy5maWx0ZXIoKHBhcnQpID0+IHBhcnQgIT09ICIiKTsKICAgIGlmIChub25FbXB0eVBhcnRzLmxlbmd0aCA8IDIpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlBsZWFzZSBwcm92aWRlIGFkZGl0aW9uYWwgcGFydHMuIik7CiAgICB9CgogICAgY29uc3Qgc2VjcmV0SGV4ID0gc2VjcmV0cy5jb21iaW5lKG5vbkVtcHR5UGFydHMpOwogICAgY29uc3Qgc2VjcmV0ID0gc2VjcmV0cy5oZXgyc3RyKHNlY3JldEhleCk7CgogICAgaWYgKCFwYXNzd29yZCkgewogICAgICAgIHJldHVybiBzZWNyZXQ7CiAgICB9CgogICAgY29uc3QgZGF0YVN0ciA9IEpTT04ucGFyc2Uoc2VjcmV0KTsKICAgIGNvbnN0IGRhdGEgPSB7CiAgICAgICAgb3B0aW9uczogZGF0YVN0ci5vcHRpb25zLAogICAgICAgIHNhbHQ6IGJhc2U2NFRvQnl0ZXMoZGF0YVN0ci5zYWx0KSwKICAgICAgICBpdjogYmFzZTY0VG9CeXRlcyhkYXRhU3RyLml2KSwKICAgICAgICBlbmNyeXB0ZWREYXRhOiBiYXNlNjRUb0J5dGVzKGRhdGFTdHIuZW5jcnlwdGVkRGF0YSksCiAgICB9OwogICAgY29uc3QgZGVjcnlwdGVkQnVmZmVyID0gYXdhaXQgZGVjcnlwdChkYXRhLCBwYXNzd29yZCk7CiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRlY3J5cHRlZEJ1ZmZlcik7Cn0KCmZ1bmN0aW9uIHVwZGF0ZVBhcnRzVWkocGFydHMpIHsKICAgIGxldCBoYXNFbXB0eUZpZWxkcyA9IGZhbHNlOwoKICAgIGZvciAoY29uc3QgW2luZGV4LCBwYXJ0XSBvZiBwYXJ0cy5lbnRyaWVzKCkpIHsKICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBpbnB1dC0ke2luZGV4fS1sYWJlbGApOwoKICAgICAgICBpZiAocGFydCAhPT0gIiIpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNlY3JldHMuZXh0cmFjdFNoYXJlQ29tcG9uZW50cyhwYXJ0KTsKICAgICAgICAgICAgICAgIGxhYmVsLmlubmVySFRNTCA9IGA8ZGl2PlBhcnQgJHtyZXN1bHQuaWR9PC9kaXY+JHtjaGVja0ljb259YDsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gYDxkaXY+SW52YWxpZCBwYXJ0PC9kaXY+JHtjcm9zc0ljb259YDsKICAgICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGxhYmVsLmlubmVySFRNTCA9IGFycm93UmlnaHRJY29uOwogICAgICAgICAgICBoYXNFbXB0eUZpZWxkcyA9IHRydWU7CiAgICAgICAgfQogICAgfQoKICAgIGlmICghaGFzRW1wdHlGaWVsZHMpIHsKICAgICAgICBjb25zdCBpbnB1dHNEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiaW5wdXRzIik7CgogICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7CiAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCJpZCIsIGBpbnB1dC0ke3BhcnRzLmxlbmd0aH0tbGFiZWxgKTsKICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoImNsYXNzIiwgInJvdyIpOwogICAgICAgIGxhYmVsLmlubmVySFRNTCA9IGFycm93UmlnaHRJY29uOwogICAgICAgIGlucHV0c0Rpdi5hcHBlbmRDaGlsZChsYWJlbCk7CgogICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaW5wdXQiKTsKICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoInBsYWNlaG9sZGVyIiwgIkVudGVyIGFub3RoZXIgcGFydCIpOwogICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgib25pbnB1dCIsICJjb21iaW5lKCkiKTsKICAgICAgICBpbnB1dHNEaXYuYXBwZW5kQ2hpbGQoaW5wdXQpOwogICAgfQp9Cgo8L3NjcmlwdD4KICAgICAgICA8c2NyaXB0PgogICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigiRE9NQ29udGVudExvYWRlZCIsICgpID0+IHsKICAgICAgICAgICAgICAgIGNvbWJpbmUoKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgPC9zY3JpcHQ+CiAgICA8L2hlYWQ+CiAgICA8Ym9keT4KICAgICAgICA8bWFpbj4KICAgICAgICAgICAgPGhlYWRlcj4KICAgICAgICAgICAgICAgIDxuYXY+CiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj0iaHR0cHM6Ly9odG1sLXZhdWx0LmNvbSI+V2Vic2l0ZTwvYT4KICAgICAgICAgICAgICAgIDwvbmF2PgogICAgICAgICAgICA8L2hlYWRlcj4KCiAgICAgICAgICAgIF9fQ1VTVE9NX0hFQURFUl9fCgogICAgICAgICAgICA8aDI+UGFydCBfX1NFTEZfUEFSVF9OVU1CRVJfXyAoX19HUk9VUF9JRF9fKTwvaDI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InNoYXJlLWNvbnRhaW5lciI+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzaGFyZSIgaWQ9InNlbGYtcGFydCI+X19TRUxGX1BBUlRfXzwvZGl2PgogICAgICAgICAgICAgICAgPGJ1dHRvbiBvbmNsaWNrPSJjb3B5VG9DbGlwYm9hcmQoJ3NlbGYtcGFydCcpIj4KICAgICAgICAgICAgICAgICAgICA8c3ZnCiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD0iMXJlbSIKICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9IjFyZW0iCiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXAtcnVsZT0iZXZlbm9kZCIKICAgICAgICAgICAgICAgICAgICAgICAgZmlsbC1ydWxlPSJldmVub2RkIgogICAgICAgICAgICAgICAgICAgICAgICBzdHJva2UtbGluZWpvaW49InJvdW5kIgogICAgICAgICAgICAgICAgICAgICAgICBzdHJva2UtbWl0ZXJsaW1pdD0iMiIKICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveD0iMCAwIDI0IDI0IgogICAgICAgICAgICAgICAgICAgICAgICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgICAgICAgICAgICAgICAgICAgPgogICAgICAgICAgICAgICAgICAgICAgICA8cGF0aAogICAgICAgICAgICAgICAgICAgICAgICAgICAgZD0ibTYgMTl2MmMwIC42MjEuNTIgMSAxIDFoMnYtMS41aC0xLjV2LTEuNXptNy41IDNoLTMuNXYtMS41aDMuNXptNC41IDBoLTMuNXYtMS41aDMuNXptNC0zaC0xLjV2MS41aC0xLjV2MS41aDJjLjQ3OCAwIDEtLjM3OSAxLTF6bS0xLjUtMXYtMy4zNjNoMS41djMuMzYzem0wLTQuMzYzdi0zLjYzN2gxLjV2My42Mzd6bS0xMy0zLjYzN3YzLjYzN2gtMS41di0zLjYzN3ptMTEuNS00djEuNWgxLjV2MS41aDEuNXYtMmMwLS40NzgtLjM3OS0xLTEtMXptLTEwIDBoLTJjLS42MiAwLTEgLjUxOS0xIDF2MmgxLjV2LTEuNWgxLjV6bTQuNSAxLjVoLTMuNXYtMS41aDMuNXptMy0xLjV2LTIuNWgtMTN2MTNoMi41di0xLjg2M2gxLjV2My4zNjNoLTQuNWMtLjQ4IDAtMS0uMzc5LTEtMXYtMTRjMC0uNDgxLjM4LTEgMS0xaDE0Yy42MjEgMCAxIC41MjIgMSAxdjQuNWgtMy41di0xLjV6IgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbC1ydWxlPSJub256ZXJvIgogICAgICAgICAgICAgICAgICAgICAgICAvPgogICAgICAgICAgICAgICAgICAgIDwvc3ZnPgogICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgPGRldGFpbHMgY2xhc3M9ImN0YSI+CiAgICAgICAgICAgICAgICA8c3VtbWFyeT4KICAgICAgICAgICAgICAgICAgICBDb21iaW5lIHdpdGggb3RoZXIgcGFydHMKICAgICAgICAgICAgICAgICAgICA8c3ZnCiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD0iMjQiCiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPSIyNCIKICAgICAgICAgICAgICAgICAgICAgICAgZmlsbD0iIzMzMzNiYiIKICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNhYmxlPSJmYWxzZSIKICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1oaWRkZW49InRydWUiCiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdCb3g9IjAgMCAyNCAyNCIKICAgICAgICAgICAgICAgICAgICA+CiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkPSJNMjIgMTJjMC01LjUyLTQuNDgtMTAtMTAtMTBTMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwbS0xMCAxSDh2LTJoNFY4bDQgNC00IDR6IgogICAgICAgICAgICAgICAgICAgICAgICA+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgIDwvc3ZnPgogICAgICAgICAgICAgICAgPC9zdW1tYXJ5PgogICAgICAgICAgICAgICAgPGgxPkNvbWJpbmUgcGFydHM8L2gxPgogICAgICAgICAgICAgICAgPHA+CiAgICAgICAgICAgICAgICAgICAgQ29tYmluZSBhcyBtYW55IHBhcnRzIGFzIG5lZWRlZCB0byByZWNvbnN0cnVjdCB0aGUgc2VjcmV0LgogICAgICAgICAgICAgICAgICAgIFRoZSBvcmRlciBkb2VzIG5vdCBtYXR0ZXIuCiAgICAgICAgICAgICAgICA8L3A+CgogICAgICAgICAgICAgICAgPGRpdiBpZD0iaW5wdXRzIj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPSJpbnB1dC0wLWxhYmVsIiBjbGFzcz0icm93Ij4KICAgICAgICAgICAgICAgICAgICAgICAgPHN2ZwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PSIyNCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPSIyNCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9IiMzMzMzYmIiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2FibGU9ImZhbHNlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1oaWRkZW49InRydWUiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3Qm94PSIwIDAgMjQgMjQiCiAgICAgICAgICAgICAgICAgICAgICAgID4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZD0iTTIyIDEyYzAtNS41Mi00LjQ4LTEwLTEwLTEwUzIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMG0tMTAgMUg4di0yaDRWOGw0IDQtNCA0eiIKICAgICAgICAgICAgICAgICAgICAgICAgICAgID48L3BhdGg+CiAgICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxpbnB1dAogICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0iRW50ZXIgYSBwYXJ0IgogICAgICAgICAgICAgICAgICAgICAgICBvbmlucHV0PSJjb21iaW5lKCkiCiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPSJfX1NFTEZfUEFSVF9fIgogICAgICAgICAgICAgICAgICAgIC8+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD0iaW5wdXQtMS1sYWJlbCIgY2xhc3M9InJvdyI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxzdmcKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD0iMjQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD0iMjQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsPSIjMzMzM2JiIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNhYmxlPSJmYWxzZSIKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtaGlkZGVuPSJ0cnVlIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveD0iMCAwIDI0IDI0IgogICAgICAgICAgICAgICAgICAgICAgICA+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cGF0aAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQ9Ik0yMiAxMmMwLTUuNTItNC40OC0xMC0xMC0xMFMyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBtLTEwIDFIOHYtMmg0VjhsNCA0LTQgNHoiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9wYXRoPgogICAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8aW5wdXQgcGxhY2Vob2xkZXI9IkVudGVyIGEgcGFydCIgb25pbnB1dD0iY29tYmluZSgpIiAvPgogICAgICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICAgICAgPHA+CiAgICAgICAgICAgICAgICAgICAgPGRldGFpbHM+CiAgICAgICAgICAgICAgICAgICAgICAgIDxzdW1tYXJ5PlBhc3N3b3JkPC9zdW1tYXJ5PgogICAgICAgICAgICAgICAgICAgICAgICA8cD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHRoZSBwYXJ0cyBhcmUgZW5jcnlwdGVkLCBlbnRlciB0aGUgcGFzc3dvcmQgdXNlZAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gZW5jcnlwdCB0aGVtLgogICAgICAgICAgICAgICAgICAgICAgICA8L3A+CiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dAogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9InBhc3N3b3JkIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT0icGFzc3dvcmQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj0iRW50ZXIgcGFzc3dvcmQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmlucHV0PSJjb21iaW5lKCkiCiAgICAgICAgICAgICAgICAgICAgICAgIC8+CiAgICAgICAgICAgICAgICAgICAgPC9kZXRhaWxzPgogICAgICAgICAgICAgICAgPC9wPgoKICAgICAgICAgICAgICAgIDxoMj5SZWNvbnN0cnVjdGVkIHNlY3JldDwvaDI+CiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJvdXRwdXQiPjwvZGl2PgogICAgICAgICAgICA8L2RldGFpbHM+CiAgICAgICAgPC9tYWluPgogICAgPC9ib2R5Pgo8L2h0bWw+Cg==";
const template = atob(template64);

</script>
        <script>
function validate(total, required, secret, password, confirmPassword) {
    if (total < 2) {
        return "Total must be at least 1";
    } else if (total > 255) {
        return "Total must be at most 255";
    } else if (required < 2) {
        return "Required must be at least 1";
    } else if (required > 255) {
        return "Required must be at most 255";
    } else if (isNaN(total)) {
        return "Invalid value for total";
    } else if (isNaN(required)) {
        return "Invalid value for required";
    } else if (required > total) {
        return "Required must be less than total";
    } else if (secret.length == 0) {
        return "Secret is blank";
    } else if (password.length > 0 && password !== confirmPassword) {
        return "Passwords do not match";
    } else {
        return undefined;
    }
}

async function getSecretContent(secretStr, password) {
    if (!password) {
        return secretStr;
    }

    const input = new TextEncoder().encode(secretStr);
    const data = await encrypt(input, password);

    const encoded = {
        options: data.options,
        salt: bytesToBase64(data.salt),
        iv: bytesToBase64(data.iv),
        encryptedData: bytesToBase64(data.encryptedData),
    };
    return JSON.stringify(encoded);
}

async function updateParts() {
    const id = createReadableId();
    const threshold = Number(document.getElementById("requiredParts").value);
    const numShares = Number(document.getElementById("totalParts").value);
    const secret = document.getElementById("secret").value;
    const password = document.getElementById("password").value;
    const confirmPassword = document.getElementById("confirmPassword").value;
    const output = document.getElementById("output");

    const error = validate(
        numShares,
        threshold,
        secret,
        password,
        confirmPassword
    );

    if (error !== undefined) {
        output.innerHTML = `<span class="placeholder error">${error}</span>`;
        return;
    }

    const padLength = 1024;

    const shares = secrets.share(
        secrets.str2hex(await getSecretContent(secret, password)),
        numShares,
        threshold,
        padLength
    );

    const fields = [];
    for (const [index, share] of shares.entries()) {
        fields.push(`<li>
                        <div class="share-container">
                            <span id="share_${index}" class="share">${share}</span>
                            <button onclick="copyToClipboard('share_${index}')">
                                ${ccIcon}
                            </button>
                        </div>
                    </li>`);
    }

    const downloadAllUrl = await createDownloadAllContent(shares, id);
    const downloadAllFileName = `parts_${id}.tar.gz`;

    output.innerHTML = `
                    <p>
                     <a href="${downloadAllUrl}" download="${downloadAllFileName}">‚è¨ Download all parts (${
        shares.length
    })</a>
                    </p>
                    <ol>
                        ${fields.join("\n")}
                    </ol>
                `;
}

function createReadableId(length = 6) {
    // Excluded: I, L, O (look like numbers) and U (to avoid accidental profanity)
    // Added: 3, 4, 7, 9 for extra entropy, but kept them distinct.
    const charset = "ABCDEFGHJKMNPQRSTVWXYZ3479";
    let result = "";

    for (let i = 0; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * charset.length);
        result += charset[randomIndex];
    }

    return result;
}

async function createDownloadAllContent(shares, id) {
    const threshold = document.getElementById("requiredParts").value;
    const customHeader = document.getElementById("customHeader").value;

    const files = shares.map((share, index) => ({
        name: `part_${index + 1}_${id}.html`,
        data: template
            .replaceAll("__SELF_PART__", share)
            .replaceAll("__THRESHOLD__", threshold)
            .replaceAll("__SELF_PART_NUMBER__", index + 1)
            .replaceAll("__CUSTOM_HEADER__", customHeader)
            .replaceAll("__GROUP_ID__", id),
    }));

    const data = await createTarGzip(files);
    const blob = new Blob([data], { type: "application/x-tar" });
    return URL.createObjectURL(blob);
}

</script>
        <style>
input.small {
    width: 2.5rem;
}

.share-container {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin-bottom: 0.5rem;
}

.share {
    font-family: monospace;
    font-size: 0.9rem;
    background-color: #f4f4f4;
    transition: background-color 0.3s ease-out;
    padding: 1rem 0.5rem;
    border-radius: 5px;
    display: inline-block;
    flex-grow: 1;
    overflow-x: hidden;
    text-overflow: ellipsis;
}

.password-fields {
    display: flex;
    gap: 1rem;
}

details {
    margin-bottom: 1rem;
}

</style>
        <script>
// From: https://github.dev/unjs/nanotar/blob/main/src/create.ts

/**
 * Creates a TAR file from a list of file inputs and options, returning the TAR file as an `Uint8Array`.
 * This function takes care of normalising the file data, setting default attributes and calculating the TAR structure.
 *
 * @param {TarFileInput[]} files - An array of files to include in the TAR archive. Each file can contain different data types. See {@link TarFileInput}.
 * @param {CreateTarOptions} opts - File creation configuration options, including default file attributes. See {@link CreateTarOptions}.
 * @returns {Uint8Array} The TAR file encoded as an `Uint8Array`.
 */
function createTar(files, opts = {}) {
    // Normalize file data in order to allow calculating final size
    const _files = files.map((file) => {
        const data = _normalizeData(file.data);
        return {
            ...file,
            data,
            size: data?.length || 0,
        };
    });

    // Create data buffer
    let tarDataSize = 0;
    for (let i = 0; i < files.length; i++) {
        const size = _files[i].data?.length ?? 0;
        tarDataSize += 512 + 512 * Math.trunc(size / 512);
        if (size % 512) {
            tarDataSize += 512;
        }
    }
    let bufSize = 10_240 * Math.trunc(tarDataSize / 10_240);
    if (tarDataSize % 10_240) {
        bufSize += 10_240;
    }
    const buffer = new ArrayBuffer(bufSize);

    let offset = 0;

    for (const file of _files) {
        const isDir = !file.data;

        // -- Header --
        // File name (offset: 0 - length: 100)
        _writeString(buffer, file.name, offset, 100);

        // File mode (offset: 100 - length: 8)
        const mode =
            file.attrs?.mode ?? opts.attrs?.mode ?? (isDir ? "775" : "664");
        _writeString(buffer, _leftPad(mode, 7), offset + 100, 8);

        // File uid (offset: 108 - length: 8)
        const uid = file.attrs?.uid ?? opts.attrs?.uid ?? 1000;
        _writeString(buffer, _leftPad(uid.toString(8), 7), offset + 108, 8);

        // File gid (offset: 116 - length: 8)
        const gid = file.attrs?.gid ?? opts.attrs?.gid ?? 1000;
        _writeString(buffer, _leftPad(gid.toString(8), 7), offset + 116, 8);

        // File size (offset: 124 - length: 12)
        _writeString(
            buffer,
            _leftPad(file.size.toString(8), 11),
            offset + 124,
            12
        );

        // File mtime (offset: 136 - length: 12)
        const mtime = file.attrs?.mtime ?? opts.attrs?.mtime ?? Date.now();
        _writeString(
            buffer,
            _leftPad(Math.trunc(mtime / 1000).toString(8), 11),
            offset + 136,
            12
        );

        // File type (offset: 156 - length: 1)
        const type = isDir ? "5" : "0";
        _writeString(buffer, type, offset + 156, 1);

        // USTAR indicator (offset: 257 - length: 512)
        _writeString(buffer, "ustar", offset + 257, 6 /* magic string */);

        // USTAR version (offset: 263 - length: 2)
        _writeString(buffer, "00", offset + 263, 2 /* magic version */);

        // File owner user (offset: 265 - length: 32)
        const user = file.attrs?.user ?? opts.attrs?.user ?? "";
        _writeString(buffer, user, offset + 265, 32);

        // File owner group (offset: 297 - length: 32)
        const group = file.attrs?.group ?? opts.attrs?.group ?? "";
        _writeString(buffer, group, offset + 297, 32);

        // Checksum (offset: 148 - length: 8) -- must be last
        _writeString(buffer, "        ", offset + 148, 8);
        const header = new Uint8Array(buffer, offset, 512);
        let chksum = 0;
        for (let i = 0; i < 512; i++) {
            chksum += header[i];
        }
        _writeString(buffer, chksum.toString(8), offset + 148, 8);

        // -- Data --
        if (!isDir) {
            const destArray = new Uint8Array(buffer, offset + 512, file.size);
            for (let byteIdx = 0; byteIdx < file.size; byteIdx++) {
                destArray[byteIdx] = file.data[byteIdx];
            }
            offset += 512 * Math.trunc(file.size / 512);
            if (file.size % 512) {
                offset += 512;
            }
        }
        offset += 512;
    }

    return new Uint8Array(buffer);
}

/**
 * Creates a gzipped TAR file stream from an array of file inputs, using optional compression settings.
 *
 * @param {TarFileInput[]} files - The files to include in the gzipped TAR archive. See {@link TarFileInput}.
 * @param {CreateTarOptions & { Compression? CompressionFormat }} opts - Options for TAR creation and gzip compression. See {@link CreateTarOptions}.
 * @returns {ReadableStream} A stream of the gzipped TAR file data.
 */
function createTarGzipStream(files, opts = {}) {
    const buffer = createTar(files, opts);
    return new ReadableStream({
        start(controller) {
            controller.enqueue(buffer);
            controller.close();
        },
    }).pipeThrough(new CompressionStream(opts.compression ?? "gzip"));
}

/**
 * Asynchronously creates a gzipped TAR file from an array of file inputs.
 * This function is suitable for scenarios where a complete gzipped TAR file is required as a single `Uint8` array.
 *
 * @param {TarFileInput[]} files - The files to include in the gzipped TAR archive.
 * @param {CreateTarOptions & { Compression? CompressionFormat }} opts - Options for TAR creation and gzip compression.
 * @returns {Promise<Uint8Array>} A promise that resolves to the gzipped TAR file as an Uint8Array.
 */
async function createTarGzip(files, opts = {}) {
    const data = await new Response(createTarGzipStream(files, opts))
        .arrayBuffer()
        .then((buffer) => new Uint8Array(buffer));
    return data;
}

function _writeString(buffer, str, offset, size) {
    const strView = new Uint8Array(buffer, offset, size);
    const te = new TextEncoder();
    const written = te.encodeInto(str, strView).written;
    for (let i = written; i < size; i++) {
        strView[i] = 0;
    }
}

function _leftPad(input, targetLength) {
    return String(input).padStart(targetLength, "0");
}

function _normalizeData(data) {
    if (data === null || data === undefined) {
        return undefined;
    }
    if (typeof data === "string") {
        return new TextEncoder().encode(data);
    }
    if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    return data;
}

</script>
        <script>
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/",
];

const base64codes = [
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255,
    255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255,
    255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
    19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29,
    30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48,
    49, 50, 51,
];

function getBase64Code(charCode) {
    if (charCode >= base64codes.length) {
        throw new Error("Unable to parse base64 string.");
    }
    const code = base64codes[charCode];
    if (code === 255 || code === undefined) {
        throw new Error("Unable to parse base64 string.");
    }
    return code;
}

function bytesToBase64(input) {
    const bytes = new Uint8Array(input);

    let result = "";
    let i = 0;
    const l = bytes.length;
    for (i = 2; i < l; i += 3) {
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
        result += base64abc[((bytes[i - 1] & 0x0f) << 2) | (bytes[i] >> 6)];
        result += base64abc[bytes[i] & 0x3f];
    }
    if (i === l + 1) {
        // 1 octet yet to write
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        // 2 octets yet to write
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
        result += base64abc[(bytes[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}

function base64ToBytes(str) {
    if (str.length % 4 !== 0) {
        throw new Error("Unable to parse base64 string.");
    }
    const index = str.indexOf("=");
    if (index !== -1 && index < str.length - 2) {
        throw new Error("Unable to parse base64 string.");
    }
    const missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0;
    const n = str.length;
    const result = new Uint8Array(3 * (n / 4));
    let buffer;
    for (let i = 0, j = 0; i < n; i += 4, j += 3) {
        buffer =
            (getBase64Code(str.charCodeAt(i)) << 18) |
            (getBase64Code(str.charCodeAt(i + 1)) << 12) |
            (getBase64Code(str.charCodeAt(i + 2)) << 6) |
            getBase64Code(str.charCodeAt(i + 3));
        result[j] = buffer >> 16;
        result[j + 1] = (buffer >> 8) & 0xff;
        result[j + 2] = buffer & 0xff;
    }
    return result.buffer.slice(0, result.length - missingOctets);
}

</script>
        <script>
function generateRandomBytes(length) {
    const bytes = new Uint8Array(length);
    window.crypto.getRandomValues(bytes);
    return bytes.buffer;
}

async function generateKeyFromPassword(password, salt, mode, options) {
    const passwordKey = await window.crypto.subtle.importKey(
        "raw",
        new TextEncoder().encode(password),
        { name: "PBKDF2" },
        false,
        ["deriveKey"]
    );

    return window.crypto.subtle.deriveKey(
        {
            name: "PBKDF2",
            salt,
            iterations: options.iterations,
            hash: "SHA-1",
        },
        passwordKey,
        {
            name: "AES-GCM",
            length: options.keySize * 8,
        },
        false,
        [mode]
    );
}

function getDefaultOptions() {
    return {
        blockSize: 16,
        saltSize: 16,
        iterations: 1000000,
        keySize: 32,
    };
}

async function encrypt(input, passwordStr, options = getDefaultOptions()) {
    const salt = generateRandomBytes(options.saltSize);
    const key = await generateKeyFromPassword(
        passwordStr,
        salt,
        "encrypt",
        options
    );

    const iv = generateRandomBytes(options.blockSize);

    const cipherBuffer = await window.crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        input
    );

    return {
        options,
        salt,
        iv,
        encryptedData: cipherBuffer,
    };
}

async function decrypt(data, passwordStr) {
    const key = await generateKeyFromPassword(
        passwordStr,
        data.salt,
        "decrypt",
        data.options
    );

    return await window.crypto.subtle.decrypt(
        {
            name: "AES-GCM",
            iv: data.iv,
        },
        key,
        data.encryptedData
    );
}

</script>
        <title>Shamir Secret Sharing Scheme</title>
        <style>
main {
    max-width: 800px;
    margin: auto;
    font-family: Arial, sans-serif;
}

:focus {
    outline-color: #4a90e2;
    outline-width: 2px;
    outline-style: solid;
}

input,
textarea {
    width: 100%;
    padding: 0.5rem;
    border-radius: 10px;
    border: 1px solid #ccc;
}

button {
    padding: 0.5rem 0.5rem;
    border-radius: 5px;
    border: 1px solid #ccc;
    cursor: pointer;
}

nav {
    display: flex;
    padding: 1rem;
    margin-bottom: 1rem;
    gap: 1rem;
    border-bottom: 1px solid #ccc;
}

</style>
    </head>
    <body>
        <main>
            <header>
                <nav>
                    <a href="">Home</a>
                    <a href="/split">Split</a>
                    <a href="/combine">Combine parts</a>
                </nav>
            </header>
            <h1>Shamir Secret Sharing Scheme</h1>
            <div>
                <p>
                    Split your secret into parts which can be combined back into
                    the original secret using some or all of the parts.
                </p>
                <p>
                    Require
                    <input
                        id="requiredParts"
                        type="number"
                        value="3"
                        min="2"
                        max="255"
                        class="small"
                        oninput="updateParts()"
                    />
                    parts from
                    <input
                        id="totalParts"
                        type="number"
                        value="5"
                        min="2"
                        max="255"
                        class="small"
                        oninput="updateParts()"
                    />
                    to reconstruct the following secret
                </p>
                <textarea
                    id="secret"
                    rows="10"
                    placeholder="Enter your secret here"
                    oninput="updateParts()"
                ></textarea>
            </div>

            <h3>Additional options</h3>
            <details>
                <summary>Password</summary>

                <p>
                    Shamir's Secret Sharing is mathematically secure (i.e.
                    information cannot be extracted without the required number
                    of parts). However, to add an additional layer of security,
                    you can optionally protect the secret with a password. The
                    password will be required to reconstruct the secret from the
                    parts.
                </p>

                <p class="password-fields">
                    <input
                        id="password"
                        type="password"
                        placeholder="Enter password here"
                        oninput="updateParts()"
                    />
                    <input
                        id="confirmPassword"
                        type="password"
                        placeholder="Confirm password"
                        oninput="updateParts()"
                    />
                </p>
            </details>

            <details>
                <summary>Custom header</summary>

                <p>
                    Optionally add a custom header to the generated parts, can
                    be useful to attach additional explanations in the parts'
                    HTML files.
                </p>
                <textarea
                    id="customHeader"
                    rows="5"
                    placeholder="Enter custom header here"
                    oninput="updateParts()"
                ></textarea>
            </details>

            <h2>Generated Parts:</h2>

            <div id="output">
                <span class="placeholder"
                    >Enter a secret and adjust the parameters to see the
                    parts</span
                >
            </div>
        </main>
    </body>
</html>
